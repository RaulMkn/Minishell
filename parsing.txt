=============================================================================
                          MINISHELL - ANÁLISIS DETALLADO DE PARSING
=============================================================================

ESQUEMA GENERAL DEL FLUJO DE PARSING:

┌─────────────────────────────────────────────────────────────────────────────┐
│                                    MAIN                                     │
│                             (execution/core/main.c)                        │
│                                                                             │
│  1. init_shell()       - Inicializa la estructura shell                    │
│  2. shell_loop()       - Bucle principal de la shell                       │
│  3. cleanup_shell()    - Limpia recursos al finalizar                      │
└─────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                               SHELL_LOOP                                   │
│                         (execution/core/shell_loop.c)                      │
│                                                                             │
│  1. readline()         - Lee entrada del usuario                           │
│  2. process_input_line() - Procesa la línea de entrada                     │
│     ├── tokenize_input()       - TOKENIZACIÓN                             │
│     ├── expand_and_filter_tokens() - EXPANSIÓN DE VARIABLES               │
│     └── process_valid_tokens()  - PARSEO Y EJECUCIÓN                      │
└─────────────────────────────────────────────────────────────────────────────┘
                                        │
                          ┌─────────────┼─────────────┐
                          ▼             ▼             ▼
                ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
                │ TOKENIZACIÓN│ │  EXPANSIÓN  │ │   PARSEO    │
                │   (LEXER)   │ │ VARIABLES   │ │  COMANDOS   │
                └─────────────┘ └─────────────┘ └─────────────┘

=============================================================================
                             FASE 1: TOKENIZACIÓN (LEXER)
=============================================================================

FUNCIÓN PRINCIPAL: tokenize_input()
ARCHIVO: parsing/lexer/tokenizer_main.c:67-79

FLUJO DE TOKENIZACIÓN:
┌─────────────────────────────────────────────────────────────────────────────┐
│                           tokenize_input()                                 │
│                                                                             │
│  1. init_lexer_state()     - Inicializa estado del lexer                   │
│  2. init_tokenizer_context() - Inicializa contexto de tokenización         │
│  3. process_input_loop()   - Procesa cada caracter de la entrada           │
│     └── process_character() - Maneja cada tipo de caracter                │
│         ├── handle_quote_char()    - Maneja comillas                      │
│         ├── handle_whitespace()    - Maneja espacios                      │
│         ├── handle_operator()      - Maneja operadores (|, <, >, <<, >>)  │
│         └── handle_regular_char()  - Maneja caracteres normales           │
│  4. finalize_tokenization() - Finaliza proceso y retorna tokens           │
└─────────────────────────────────────────────────────────────────────────────┘

FUNCIONES DE SOPORTE DEL LEXER:

1. BUFFER_HANDLER.C (parsing/lexer/buffer_handler.c):
   - handle_buffer_token()    - Convierte buffer en token WORD
   - handle_final_buffer()    - Maneja buffer final de tokenización
   - create_word_token()      - Crea token de tipo palabra

2. QUOTE_HANDLER.C (parsing/lexer/quote_handler.c):
   - handle_quote_char()      - Procesa caracteres de comillas
   - Maneja estados: QUOTE_NONE, QUOTE_SINGLE, QUOTE_DOUBLE

3. OPERATOR_HANDLER.C (parsing/lexer/operator_handler.c):
   - handle_operator()        - Procesa operadores de redirección y pipes
   - create_operator_token()  - Crea tokens de operadores específicos

4. TOKEN_UTILS.C (parsing/lexer/token_utils.c):
   - create_token()           - Crea nuevo token con tipo y valor
   - token_add_back()         - Añade token al final de la lista

5. TOKENIZER_CONTEXT.C (parsing/lexer/tokenizer_context.c):
   - init_tokenizer_context() - Inicializa contexto de tokenización
   - set_tokenizer_input()    - Establece entrada a tokenizar

TIPOS DE TOKENS GENERADOS:
- TOKEN_WORD      : Palabras/comandos/argumentos
- TOKEN_PIPE      : Operador pipe '|'
- TOKEN_REDIR_IN  : Redirección entrada '<'
- TOKEN_REDIR_OUT : Redirección salida '>'
- TOKEN_APPEND    : Redirección append '>>'
- TOKEN_HEREDOC   : Here document '<<'
- TOKEN_REDIR_ERR : Redirección error '2>'

=============================================================================
                           FASE 2: EXPANSIÓN DE VARIABLES
=============================================================================

FUNCIÓN PRINCIPAL: expand_and_filter_tokens()
ARCHIVO: parsing/expand_tokens.c:51-76

FLUJO DE EXPANSIÓN:
┌─────────────────────────────────────────────────────────────────────────────┐
│                      expand_and_filter_tokens()                            │
│                                                                             │
│  Para cada token de tipo TOKEN_WORD:                                       │
│  1. expand_variables()     - Expande variables en el valor del token       │
│  2. update_token_value()   - Actualiza valor del token con resultado       │
│  3. remove_empty_token()   - Elimina tokens vacíos resultantes             │
└─────────────────────────────────────────────────────────────────────────────┘

FUNCIONES DE EXPANSIÓN DE VARIABLES:

1. VARIABLE_EXPANSION.C (parsing/variable_expansion.c):
   - expand_variables()                - Función principal de expansión
   - expand_and_filter_tokens()        - Aplica expansión a lista de tokens
   - process_expansion_loop()          - Bucle de procesamiento de expansión

2. VARIABLE_EXPANSION_CORE.C:
   - get_var_value()                   - Obtiene valor de variable de entorno
   - get_var_name_length()             - Calcula longitud del nombre de variable
   - handle_pid_expansion_ext()        - Maneja expansión de $$ (PID)

3. VARIABLE_EXPANSION_COMPLEX.C:
   - expand_complex_variables()        - Expansión de variables complejas
   - handle_quoted_expansion()         - Maneja expansión dentro de comillas

4. VARIABLE_EXPANSION_HELPERS.C:
   - handle_variable_expansion_ext()   - Expansión extendida de variables
   - process_character_expansion()     - Procesa cada caracter para expansión

5. VARIABLE_EXPANSION_UTILS.C:
   - Funciones auxiliares para expansión de variables

TIPOS DE EXPANSIÓN SOPORTADOS:
- $VAR o ${VAR}  : Variables de entorno
- $?             : Código de salida del último comando
- $$             : PID del proceso actual
- $#             : Número de argumentos posicionales
- Expansión dentro de comillas dobles (no en comillas simples)

=============================================================================
                            FASE 3: VALIDACIÓN DE TOKENS
=============================================================================

FUNCIÓN PRINCIPAL: is_valid_operator_sequence()
ARCHIVO: parsing/token_validation.c:45-64

VALIDACIONES REALIZADAS:
┌─────────────────────────────────────────────────────────────────────────────┐
│                      is_valid_operator_sequence()                          │
│                                                                             │
│  1. check_sequence_start_end() - Verifica que no inicie/termine con pipe   │
│  2. check_pipe_syntax()        - Valida sintaxis de pipes                  │
│  3. check_redirection_file()   - Valida que redirecciones tengan archivo   │
│                                                                             │
│  REGLAS DE VALIDACIÓN:                                                     │
│  - No puede empezar o terminar con pipe                                    │
│  - No puede haber pipes consecutivos                                       │
│  - Toda redirección debe tener un archivo asociado                         │
│  - El archivo debe ser de tipo TOKEN_WORD                                  │
└─────────────────────────────────────────────────────────────────────────────┘

=============================================================================
                             FASE 4: PARSEO DE COMANDOS
=============================================================================

FUNCIÓN PRINCIPAL: parse_tokens()
ARCHIVO: parsing/tokens/token_parser.c:72-83

FLUJO DE PARSEO:
┌─────────────────────────────────────────────────────────────────────────────┐
│                            parse_tokens()                                  │
│                                                                             │
│  1. concatenate_consecutive_tokens() - Concatena tokens consecutivos       │
│  2. parse_tokens_loop()             - Bucle principal de parseo            │
│     ├── handle_word_token()         - Procesa tokens WORD y redirecciones │
│     │   └── init_new_command()      - Crea nuevo comando                  │
│     │       └── parse_command_parts() - Parsea partes del comando         │
│     │           ├── pars_argv_redirections() - Parsea argumentos         │
│     │           └── parse_redirections_mixed() - Parsea redirecciones    │
│     └── handle_pipe_token()         - Procesa tokens PIPE                 │
└─────────────────────────────────────────────────────────────────────────────┘

FUNCIONES DE PARSEO DE COMANDOS:

1. TOKEN_PARSER_HELPERS.C (parsing/tokens/token_parser_helpers.c):
   - parse_command_parts()             - Parsea argumentos y redirecciones
   - setup_empty_command()             - Configura comando vacío con ":"

2. ARGV_PARSER.C (parsing/tokens/argv_parser.c):
   - pars_argv_redirections()          - Extrae argumentos saltando redirecciones
   - process_token()                   - Procesa cada token individual
   - add_cleaned_arg()                 - Añade argumento limpiando comillas

3. REDIRECTION_PARSER.C (parsing/tokens/redirection_parser.c):
   - parse_redirections_mixed()        - Parsea todas las redirecciones
   - create_redirection()              - Crea estructura de redirección
   - get_redir_type()                  - Convierte token type a redir type
   - add_new_redirection()             - Añade redirección a la lista

ESTRUCTURAS RESULTANTES:
┌─────────────────────────────────────────────────────────────────────────────┐
│                          ESTRUCTURA t_command                              │
│                                                                             │
│  typedef struct s_command {                                                 │
│      char        **argv;     - Array de argumentos del comando             │
│      t_redir     *redir;     - Lista de redirecciones                      │
│      struct s_command *next; - Siguiente comando (para pipes)              │
│  } t_command;                                                               │
│                                                                             │
│                          ESTRUCTURA t_redir                                │
│                                                                             │
│  typedef struct s_redir {                                                   │
│      t_redir_type  type;     - Tipo de redirección                         │
│      char         *file;     - Archivo de redirección                      │
│      struct s_redir *next;   - Siguiente redirección                       │
│  } t_redir;                                                                 │
└─────────────────────────────────────────────────────────────────────────────┘

=============================================================================
                        RELACIÓN CON FUNCIÓN MAIN
=============================================================================

FLUJO DESDE MAIN:
┌─────────────────────────────────────────────────────────────────────────────┐
│  main() [execution/core/main.c:15-28]                                      │
│  │                                                                         │
│  ├── init_shell()                   - Inicializa shell y entorno          │
│  ├── setup_interactive_signals()    - Configura manejo de señales         │
│  ├── shell_loop()                   - ENTRADA AL SISTEMA DE PARSING       │
│  │   │                                                                     │
│  │   └── process_input_line() [shell_loop.c:62-83]                        │
│  │       │                                                                 │
│  │       ├── tokenize_input()       - FASE 1: TOKENIZACIÓN               │
│  │       ├── expand_and_filter_tokens() - FASE 2: EXPANSIÓN              │
│  │       └── process_valid_tokens()  - FASE 3: VALIDACIÓN Y PARSEO       │
│  │           │                                                             │
│  │           ├── is_valid_operator_sequence() - Validación                │
│  │           ├── parse_tokens()      - FASE 4: PARSEO DE COMANDOS        │
│  │           └── execute_pipeline()  - EJECUCIÓN                          │
│  │                                                                         │
│  ├── cleanup_shell()               - Limpieza final                       │
│  └── rl_clear_history()            - Limpia historial readline             │
└─────────────────────────────────────────────────────────────────────────────┘

INTEGRACIÓN ENTRE COMPONENTES:
- shell->lexer_state: Mantiene estado del lexer entre llamadas
- shell->cmd_list: Almacena lista de comandos parseados
- shell->envp: Variables de entorno para expansión
- shell->last_status: Código de salida para expansión de $?

=============================================================================
                         RELACIONES ENTRE FUNCIONES DE PARSING
=============================================================================

DEPENDENCIAS FUNCIONALES:

1. TOKENIZACIÓN → EXPANSIÓN:
   ┌─────────────────┐     ┌─────────────────┐
   │ tokenize_input()│────▶│expand_and_filter│
   │                 │     │    _tokens()    │
   │ Genera t_token* │     │ Modifica tokens │
   └─────────────────┘     └─────────────────┘

2. EXPANSIÓN → VALIDACIÓN:
   ┌─────────────────┐     ┌─────────────────┐
   │expand_and_filter│────▶│is_valid_operator│
   │    _tokens()    │     │   _sequence()   │
   │ Tokens expandidos│     │ Valida sintaxis │
   └─────────────────┘     └─────────────────┘

3. VALIDACIÓN → PARSEO:
   ┌─────────────────┐     ┌─────────────────┐
   │is_valid_operator│────▶│  parse_tokens() │
   │   _sequence()   │     │                 │
   │ Tokens válidos  │     │ Genera comandos │
   └─────────────────┘     └─────────────────┘

INTERDEPENDENCIAS EN PARSEO:
   ┌─────────────────┐
   │  parse_tokens() │
   └─────────┬───────┘
             │
   ┌─────────▼───────┐     ┌─────────────────┐
   │parse_command_   │────▶│pars_argv_      │
   │    parts()      │     │ redirections() │
   └─────────┬───────┘     └─────────────────┘
             │
   ┌─────────▼───────┐
   │parse_redirections│
   │    _mixed()     │
   └─────────────────┘

=============================================================================
                           FUNCIONES DE PARSING DETALLADAS
=============================================================================

1. TOKENIZE_INPUT() [parsing/lexer/tokenizer_main.c:67-79]
   ────────────────────────────────────────────────────────
   PROPÓSITO: Convierte string de entrada en lista de tokens
   
   PARÁMETROS:
   - char *input: Línea de entrada del usuario
   - t_shell *shell: Estructura shell con estado del lexer
   
   RETORNA: t_token* - Lista enlazada de tokens
   
   PROCESO:
   1. Inicializa estado del lexer (comillas, errores)
   2. Inicializa contexto de tokenización (buffer, índice)
   3. Procesa caracter por caracter:
      - Comillas: Cambia estado de comillas
      - Espacios: Crea token si hay buffer
      - Operadores: Crea tokens de operadores
      - Otros: Añade al buffer
   4. Finaliza tokenización creando último token si necesario

2. EXPAND_AND_FILTER_TOKENS() [parsing/expand_tokens.c:51-76]
   ─────────────────────────────────────────────────────────────
   PROPÓSITO: Expande variables en tokens WORD y filtra vacíos
   
   PARÁMETROS:
   - t_token **tokens: Puntero a lista de tokens a expandir
   - t_shell *shell: Estructura shell con entorno y estado
   
   PROCESO:
   1. Itera por todos los tokens
   2. Para cada TOKEN_WORD:
      - Llama a expand_variables()
      - Actualiza valor del token
      - Elimina token si queda vacío
   3. Mantiene integridad de la lista enlazada

3. EXPAND_VARIABLES() [parsing/variable_expansion.c:30-49]
   ───────────────────────────────────────────────────────────
   PROPÓSITO: Expande variables de entorno en un string
   
   PARÁMETROS:
   - char *str: String a expandir
   - char **env: Array de variables de entorno
   - int last_status: Código de salida para $?
   - int len: Longitud del string (recalculada)
   
   RETORNA: char* - String con variables expandidas
   
   PROCESO:
   1. Maneja expansión especial en comillas
   2. Procesa caracter por caracter:
      - '$' seguido de nombre: Expande variable
      - '$$': Expande a PID del proceso
      - '$?': Expande a código de salida
      - Otros: Copia literalmente

4. IS_VALID_OPERATOR_SEQUENCE() [parsing/token_validation.c:45-64]
   ────────────────────────────────────────────────────────────────
   PROPÓSITO: Valida sintaxis de operadores en secuencia de tokens
   
   PARÁMETROS:
   - t_token *tokens: Lista de tokens a validar
   
   RETORNA: int - 1 si válido, 0 si inválido
   
   VALIDACIONES:
   1. No debe empezar con pipe
   2. No debe terminar con pipe
   3. No pipes consecutivos
   4. Toda redirección debe tener archivo (TOKEN_WORD)

5. PARSE_TOKENS() [parsing/tokens/token_parser.c:72-83]
   ──────────────────────────────────────────────────────────
   PROPÓSITO: Convierte tokens en estructura de comandos
   
   PARÁMETROS:
   - t_token *tokens: Lista de tokens validados
   
   RETORNA: t_command* - Lista de comandos para ejecutar
   
   PROCESO:
   1. Concatena tokens consecutivos si necesario
   2. Itera por tokens:
      - TOKEN_WORD/redirecciones: Crea nuevo comando
      - TOKEN_PIPE: Prepara para siguiente comando
   3. Para cada comando parsea argumentos y redirecciones

6. PARSE_COMMAND_PARTS() [parsing/tokens/token_parser_helpers.c:37-50]
   ───────────────────────────────────────────────────────────────────
   PROPÓSITO: Parsea argumentos y redirecciones de un comando
   
   PARÁMETROS:
   - t_command *cmd: Estructura de comando a llenar
   - t_token **curr_token: Puntero a token actual
   
   RETORNA: int - 1 si éxito, 0 si error
   
   PROCESO:
   1. Parsea argumentos con pars_argv_redirections()
   2. Parsea redirecciones con parse_redirections_mixed()
   3. Si no hay argumentos pero sí redirecciones, usa ":"

7. PARS_ARGV_REDIRECTIONS() [parsing/tokens/argv_parser.c:61-85]
   ─────────────────────────────────────────────────────────────────
   PROPÓSITO: Extrae argumentos de comando saltando redirecciones
   
   PARÁMETROS:
   - t_token **tokens: Puntero a lista de tokens
   
   RETORNA: char** - Array de argumentos NULL-terminated
   
   PROCESO:
   1. Itera hasta encontrar pipe o final
   2. Para TOKEN_WORD: Añade a argv limpiando comillas
   3. Para redirecciones: Salta token y archivo
   4. Construye array dinámicamente

8. PARSE_REDIRECTIONS_MIXED() [parsing/tokens/redirection_parser.c:72-95]
   ──────────────────────────────────────────────────────────────────────
   PROPÓSITO: Extrae todas las redirecciones mezcladas con argumentos
   
   PARÁMETROS:
   - t_token **tokens: Puntero a lista de tokens
   
   RETORNA: t_redir* - Lista de redirecciones
   
   PROCESO:
   1. Itera hasta encontrar pipe o final
   2. Para tokens de redirección:
      - Verifica que sigue TOKEN_WORD (archivo)
      - Crea estructura t_redir
      - Añade a lista de redirecciones
   3. Convierte tipo de token a tipo de redirección

=============================================================================
                            MANEJO DE ERRORES EN PARSING
=============================================================================

TIPOS DE ERROR (definidos en minishell.h):
- ERROR_NONE            : Sin error
- ERROR_SYNTAX          : Error de sintaxis
- ERROR_MEMORY          : Error de memoria
- ERROR_INVALID_OPERATOR: Operador inválido

DETECCIÓN DE ERRORES:
1. En tokenización:
   - Comillas sin cerrar
   - Secuencias prohibidas (&&, ||, ;, etc.)
   - Errores de memoria en creación de tokens

2. En validación:
   - Sintaxis incorrecta de operadores
   - Pipes mal posicionados
   - Redirecciones sin archivo

3. En parseo:
   - Fallo en asignación de memoria
   - Tokens malformados

MANEJO DE ERRORES EN SHELL_LOOP:
- Si lexer_state.error != ERROR_NONE:
  - Imprime mensaje de error
  - Libera recursos
  - Resetea estado de error
  - No ejecuta comando

=============================================================================
                              OPTIMIZACIONES Y NOTAS
=============================================================================

OPTIMIZACIONES IMPLEMENTADAS:
1. Reutilización de buffer en tokenización
2. Concatenación de tokens consecutivos
3. Filtrado de tokens vacíos tras expansión
4. Validación temprana para evitar parseo innecesario

LIMITACIONES RESPECTO A NORMA 42:
- Sin operadores prohibidos (&&, ||, ;, \, etc.)
- Sin operador ternario
- Funciones limitadas según norma 42 Madrid
- Gestión explícita de memoria sin librerías externas

COMPATIBILIDAD CON BASH:
- Expansión de variables de entorno
- Redirecciones múltiples
- Pipes entre comandos
- Here documents (<<)
- Manejo de comillas simples y dobles
- Códigos de salida ($?)

ESTRUCTURA DE ARCHIVOS:
parsing/
├── lexer/              - Tokenización y análisis léxico
├── tokens/             - Parseo de tokens a comandos
├── variable_expansion* - Expansión de variables
├── token_validation.c  - Validación de sintaxis
└── parsing_utils.c     - Utilidades generales

=============================================================================
                                  CONCLUSIÓN
=============================================================================

El sistema de parsing de Minishell implementa un pipeline completo:

ENTRADA → TOKENIZACIÓN → EXPANSIÓN → VALIDACIÓN → PARSEO → EJECUCIÓN

Cada fase es modular y mantenible, con separación clara de responsabilidades:
- Lexer: Análisis léxico y tokenización
- Expander: Expansión de variables y filtrado
- Validator: Validación de sintaxis
- Parser: Construcción de estructura de comandos

La integración con main() es a través de shell_loop(), que orquesta todo
el proceso de parsing y pasa los comandos parseados al sistema de ejecución.

La arquitectura permite extensibilidad futura y mantiene la compatibilidad
con las reglas estrictas de 42, evitando funciones prohibidas y operadores
ternarios, mientras implementa la funcionalidad core de una shell POSIX.